// Autogenerated. Do not perceive.

use anyhow::Result;
use hecs::serialize::column::{
    deserialize as deserialize_world_column, deserialize_column, serialize as serialize_world_column,
    try_serialize, try_serialize_id, DeserializeContext, SerializeContext,
};
use hecs::{ColumnBatchBuilder, ColumnBatchType, World};
use serde::{Deserialize, Serialize};

use crate::{
    Attack, BlocksEnemySpawn, DespawnOnImpact, DespawnOnTick, DespawnRandomly, Drops, Enemy,
    EnemyTarget, Energy, Health, Inventory, Jump, MoveCost, MovingInto, NewlyAdded, Obstruction,
    Plant, PlayerCharacter, Position, RangedAttack, Render, ShrinkOnDeath, Velocity, CreatedAt
};

macro_rules! with_world_components {
    ($m:ident) => {
        $m! {
            PlayerCharacter => PlayerCharacter,
            Position => Position,
            MovingInto => MovingInto,
            Health => Health,
            ShrinkOnDeath => ShrinkOnDeath,
            Render => Render,
            Attack => Attack,
            RangedAttack => RangedAttack,
            DespawnOnTick => DespawnOnTick,
            DespawnRandomly => DespawnRandomly,
            EnemyTarget => EnemyTarget,
            Enemy => Enemy,
            MoveCost => MoveCost,
            Velocity => Velocity,
            Obstruction => Obstruction,
            Energy => Energy,
            Drops => Drops,
            Jump => Jump,
            DespawnOnImpact => DespawnOnImpact,
            Inventory => Inventory,
            Plant => Plant,
            NewlyAdded => NewlyAdded,
            BlocksEnemySpawn => BlocksEnemySpawn,
            CreatedAt => CreatedAt,
        }
    };
}

macro_rules! define_component_id_enum {
    ($($ty:ty => $id:ident,)*) => {
        #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
        enum WorldComponentId {
            $($id,)*
        }
    };
}

with_world_components!(define_component_id_enum);

struct WorldColumnSerializeContext;

impl SerializeContext for WorldColumnSerializeContext {
    fn component_count(&self, archetype: &hecs::Archetype) -> usize {
        macro_rules! count_components {
            ($($ty:ty => $id:ident,)*) => {{
                let mut count = 0usize;
                $(if archetype.has::<$ty>() { count += 1; })*
                count
            }};
        }
        with_world_components!(count_components)
    }

    fn serialize_component_ids<S: serde::ser::SerializeTuple>(
        &mut self,
        archetype: &hecs::Archetype,
        mut out: S,
    ) -> std::result::Result<S::Ok, S::Error> {
        macro_rules! serialize_component_ids {
            ($($ty:ty => $id:ident,)*) => {
                $(try_serialize_id::<$ty, _, _>(archetype, &WorldComponentId::$id, &mut out)?;)*
            };
        }
        with_world_components!(serialize_component_ids);
        out.end()
    }

    fn serialize_components<S: serde::ser::SerializeTuple>(
        &mut self,
        archetype: &hecs::Archetype,
        mut out: S,
    ) -> std::result::Result<S::Ok, S::Error> {
        macro_rules! serialize_components {
            ($($ty:ty => $id:ident,)*) => {
                $(try_serialize::<$ty, _>(archetype, &mut out)?;)*
            };
        }
        with_world_components!(serialize_components);
        out.end()
    }
}

#[derive(Default)]
struct WorldColumnDeserializeContext {
    components: Vec<WorldComponentId>,
}

impl DeserializeContext for WorldColumnDeserializeContext {
    fn deserialize_component_ids<'de, A>(
        &mut self,
        mut seq: A,
    ) -> std::result::Result<ColumnBatchType, A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        self.components.clear();
        let mut batch = ColumnBatchType::new();
        while let Some(id) = seq.next_element()? {
            macro_rules! add_component_match {
                ($($ty:ty => $variant:ident,)*) => {
                    match id {
                        $(WorldComponentId::$variant => batch.add::<$ty>(),)*
                    }
                };
            }
            with_world_components!(add_component_match);
            self.components.push(id);
        }
        Ok(batch)
    }

    fn deserialize_components<'de, A>(
        &mut self,
        entity_count: u32,
        mut seq: A,
        batch: &mut ColumnBatchBuilder,
    ) -> std::result::Result<(), A::Error>
    where
        A: serde::de::SeqAccess<'de>,
    {
        for component in &self.components {
            macro_rules! deserialize_component_match {
                ($($ty:ty => $variant:ident,)*) => {
                    match component {
                        $(WorldComponentId::$variant => deserialize_column::<$ty, _>(entity_count, &mut seq, batch)?,)*
                    }
                };
            }
            with_world_components!(deserialize_component_match);
        }
        Ok(())
    }
}

struct WorldBlob<'a>(&'a World);

impl Serialize for WorldBlob<'_> {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let mut context = WorldColumnSerializeContext;
        serialize_world_column(self.0, &mut context, serializer)
    }
}

struct WorldOwned(World);

impl<'de> Deserialize<'de> for WorldOwned {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let mut context = WorldColumnDeserializeContext::default();
        deserialize_world_column(&mut context, deserializer).map(Self)
    }
}

pub fn serialize_world_to_bytes(world: &World) -> Result<Vec<u8>> {
    Ok(bincode::serde::encode_to_vec(
        WorldBlob(world),
        bincode::config::standard(),
    )?)
}

pub fn deserialize_world_from_bytes(data: &[u8]) -> Result<World> {
    let (world, _): (WorldOwned, usize) =
        bincode::serde::decode_from_slice(data, bincode::config::standard())?;
    Ok(world.0)
}
